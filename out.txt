golangci-lint run
ccx_notification_writer.go:521:1: calculated cyclomatic complexity for function doSelectedOperation is 19, max is 10 (cyclop)
func doSelectedOperation(configuration *ConfigStruct, cliFlags CliFlags) (int, error) {
^
db_benchmark_test.go:443:1: calculated cyclomatic complexity for function runBenchmarkSelectOrDeleteFromReportedTable is 12, max is 10 (cyclop)
func runBenchmarkSelectOrDeleteFromReportedTable(b *testing.B, insertFunction insertIntoReportedFunc,
^
ccx_notification_writer.go:56:2: import 'github.com/RedHatInsights/insights-operator-utils/logger' is not allowed from list 'Main' (depguard)
	"github.com/RedHatInsights/insights-operator-utils/logger"
	^
ccx_notification_writer.go:57:2: import 'github.com/RedHatInsights/insights-operator-utils/migrations' is not allowed from list 'Main' (depguard)
	utils "github.com/RedHatInsights/insights-operator-utils/migrations"
	^
ccx_notification_writer.go:58:2: import 'github.com/prometheus/client_golang/prometheus/promhttp' is not allowed from list 'Main' (depguard)
	"github.com/prometheus/client_golang/prometheus/promhttp"
	^
ccx_notification_writer.go:60:2: import 'github.com/Shopify/sarama' is not allowed from list 'Main' (depguard)
	"github.com/Shopify/sarama"
	^
ccx_notification_writer.go:62:2: import 'github.com/rs/zerolog' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog"
	^
ccx_notification_writer.go:63:2: import 'github.com/rs/zerolog/log' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog/log"
	^
ccx_notification_writer_test.go:29:2: import 'github.com/rs/zerolog' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog"
	^
ccx_notification_writer_test.go:31:2: import 'github.com/stretchr/testify/assert' is not allowed from list 'Main' (depguard)
	"github.com/stretchr/testify/assert"
	^
ccx_notification_writer_test.go:32:2: import 'github.com/tisnik/go-capture' is not allowed from list 'Main' (depguard)
	"github.com/tisnik/go-capture"
	^
ccx_notification_writer_test.go:34:2: import 'github.com/RedHatInsights/ccx-notification-writer' is not allowed from list 'Main' (depguard)
	main "github.com/RedHatInsights/ccx-notification-writer"
	^
config.go:94:2: import 'github.com/BurntSushi/toml' is not allowed from list 'Main' (depguard)
	"github.com/BurntSushi/toml"
	^
config.go:95:2: import 'github.com/RedHatInsights/insights-operator-utils/logger' is not allowed from list 'Main' (depguard)
	"github.com/RedHatInsights/insights-operator-utils/logger"
	^
config.go:99:2: import 'github.com/redhatinsights/app-common-go/pkg/api/v1' is not allowed from list 'Main' (depguard)
	clowder "github.com/redhatinsights/app-common-go/pkg/api/v1"
	^
config.go:101:2: import 'github.com/rs/zerolog/log' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog/log"
	^
config.go:102:2: import 'github.com/spf13/viper' is not allowed from list 'Main' (depguard)
	"github.com/spf13/viper"
	^
config_benchmark_test.go:27:2: import 'github.com/RedHatInsights/ccx-notification-writer' is not allowed from list 'Main' (depguard)
	main "github.com/RedHatInsights/ccx-notification-writer"
	^
config_test.go:31:2: import 'github.com/redhatinsights/app-common-go/pkg/api/v1' is not allowed from list 'Main' (depguard)
	clowder "github.com/redhatinsights/app-common-go/pkg/api/v1"
	^
config_test.go:32:2: import 'github.com/rs/zerolog' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog"
	^
config_test.go:33:2: import 'github.com/stretchr/testify/assert' is not allowed from list 'Main' (depguard)
	"github.com/stretchr/testify/assert"
	^
config_test.go:35:2: import 'github.com/RedHatInsights/ccx-notification-writer' is not allowed from list 'Main' (depguard)
	main "github.com/RedHatInsights/ccx-notification-writer"
	^
consumer.go:36:2: import 'github.com/RedHatInsights/insights-operator-utils/tls' is not allowed from list 'Main' (depguard)
	tlsutils "github.com/RedHatInsights/insights-operator-utils/tls"
	^
consumer.go:37:2: import 'github.com/RedHatInsights/insights-results-types' is not allowed from list 'Main' (depguard)
	types "github.com/RedHatInsights/insights-results-types"
	^
consumer.go:38:2: import 'github.com/Shopify/sarama' is not allowed from list 'Main' (depguard)
	"github.com/Shopify/sarama"
	^
consumer.go:39:2: import 'github.com/google/uuid' is not allowed from list 'Main' (depguard)
	"github.com/google/uuid"
	^
consumer.go:40:2: import 'github.com/rs/zerolog/log' is not allowed from list 'Main' (depguard)
	"github.com/rs/zerolog/log"
	^
consumer_test.go:33:2: import 'github.com/stretchr/testify/assert' is not allowed from list 'Main' (depguard)
	"github.com/stretchr/testify/assert"
	^
db_benchmark_test.go:47:2: import 'github.com/google/uuid' is not allowed from list 'Main' (depguard)
	"github.com/google/uuid"
	^
kafka_producer.go:32:2: import 'github.com/RedHatInsights/insights-results-types' is not allowed from list 'Main' (depguard)
	types "github.com/RedHatInsights/insights-results-types"
	^
kafka_producer.go:33:2: import 'github.com/Shopify/sarama' is not allowed from list 'Main' (depguard)
	"github.com/Shopify/sarama"
	^
kafka_producer_test.go:28:2: import 'github.com/RedHatInsights/insights-operator-utils/tests/helpers' is not allowed from list 'Main' (depguard)
	"github.com/RedHatInsights/insights-operator-utils/tests/helpers"
	^
kafka_producer_test.go:30:2: import 'github.com/Shopify/sarama/mocks' is not allowed from list 'Main' (depguard)
	"github.com/Shopify/sarama/mocks"
	^
logging_test.go:35:2: import 'github.com/tisnik/go-capture' is not allowed from list 'Main' (depguard)
	"github.com/tisnik/go-capture"
	^
metrics.go:29:2: import 'github.com/prometheus/client_golang/prometheus' is not allowed from list 'Main' (depguard)
	"github.com/prometheus/client_golang/prometheus"
	^
metrics.go:30:2: import 'github.com/prometheus/client_golang/prometheus/promauto' is not allowed from list 'Main' (depguard)
	"github.com/prometheus/client_golang/prometheus/promauto"
	^
mig_0001_create_events_targets_tbl.go:28:2: import 'github.com/RedHatInsights/insights-operator-utils/migrations' is not allowed from list 'Main' (depguard)
	mig "github.com/RedHatInsights/insights-operator-utils/migrations"
	^
mig_0001_create_events_targets_tbl.go:29:2: import 'github.com/RedHatInsights/insights-results-types' is not allowed from list 'Main' (depguard)
	types "github.com/RedHatInsights/insights-results-types"
	^
mig_0002_add_event_target_col.go:28:2: import 'github.com/RedHatInsights/insights-operator-utils/migrations' is not allowed from list 'Main' (depguard)
	mig "github.com/RedHatInsights/insights-operator-utils/migrations"
	^
migration_test.go:30:2: import 'github.com/DATA-DOG/go-sqlmock' is not allowed from list 'Main' (depguard)
	"github.com/DATA-DOG/go-sqlmock"
	^
scram_client.go:3:8: import 'github.com/xdg/scram' is not allowed from list 'Main' (depguard)
import "github.com/xdg/scram"
       ^
storage.go:44:2: import 'github.com/lib/pq' is not allowed from list 'Main' (depguard)
	_ "github.com/lib/pq"           // PostgreSQL database driver
	^
storage.go:45:2: import 'github.com/mattn/go-sqlite3' is not allowed from list 'Main' (depguard)
	_ "github.com/mattn/go-sqlite3" // SQLite database driver
	^
storage_test.go:32:2: import 'github.com/DATA-DOG/go-sqlmock' is not allowed from list 'Main' (depguard)
	"github.com/DATA-DOG/go-sqlmock"
	^
migration_test.go:102: 102-139 lines are duplicate of `migration_test.go:186-222` (dupl)
func Test0001MigrationStepUp(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	// initial database version
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("0")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultCreate := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedCreate := "CREATE TABLE IF NOT EXISTS event_targets .*"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedCreate).WillReturnResult(resultCreate)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 1
	assert.NoError(t, main.Migrate(connection, 1))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:186: 186-222 lines are duplicate of `migration_test.go:358-394` (dupl)
func Test0001MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("1")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultDrop := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedDrop := "DROP TABLE event_targets"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedDrop).WillReturnResult(resultDrop)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 0
	assert.NoError(t, main.Migrate(connection, 0))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:270: 270-309 lines are duplicate of `migration_test.go:623-660` (dupl)
func Test0002MigrationStepUp(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("0")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultCreate := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)
	resultAlter := sqlmock.NewResult(0, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedCreate := "CREATE TABLE IF NOT EXISTS event_targets .*"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"
	expectedAlter := "ALTER TABLE reported ADD COLUMN .*"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedCreate).WillReturnResult(resultCreate)
	mock.ExpectExec(expectedAlter).WillReturnResult(resultAlter)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 2
	assert.NoError(t, main.Migrate(connection, 2))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:358: 358-394 lines are duplicate of `migration_test.go:539-575` (dupl)
func Test0002MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("2")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultDrop := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedDrop := "ALTER TABLE reported DROP COLUMN event_type_id"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedDrop).WillReturnResult(resultDrop)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 1
	assert.NoError(t, main.Migrate(connection, 1))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:539: 539-575 lines are duplicate of `migration_test.go:793-829` (dupl)
func Test0003MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("3")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultDelete := sqlmock.NewResult(0, 2)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedDelete := "DELETE FROM event_targets"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedDelete).WillReturnResult(resultDelete)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 2
	assert.NoError(t, main.Migrate(connection, 2))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:623: 623-660 lines are duplicate of `migration_test.go:707-746` (dupl)
func Test0004MigrationStepUp(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("3")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultUpdate1 := sqlmock.NewResult(1, 1)
	resultAlter := sqlmock.NewResult(0, 1)
	resultUpdate2 := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedUpdate1 := "UPDATE reported SET event_type_id = 1 WHERE event_type_id IS NULL"
	expectedAlter := "ALTER TABLE reported ALTER COLUMN event_type_id SET NOT NULL"
	expectedUpdate2 := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedUpdate1).WillReturnResult(resultUpdate1)
	mock.ExpectExec(expectedAlter).WillReturnResult(resultAlter)
	mock.ExpectExec(expectedUpdate2).WillReturnResult(resultUpdate2)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())
	assert.NoError(t, main.Migrate(connection, 4))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:707: 707-746 lines are duplicate of `migration_test.go:270-309` (dupl)
func Test0004MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("4")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultAlter := sqlmock.NewResult(0, 2)
	resultUpdate1 := sqlmock.NewResult(1, 1)
	resultUpdate2 := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedAlter := "ALTER TABLE reported ALTER COLUMN event_type_id DROP NOT NULL"
	expectedUpdate1 := "UPDATE reported SET event_type_id = NULL WHERE event_type_id = 1"
	expectedUpdate2 := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedAlter).WillReturnResult(resultAlter)
	mock.ExpectExec(expectedUpdate1).WillReturnResult(resultUpdate1)
	mock.ExpectExec(expectedUpdate2).WillReturnResult(resultUpdate2)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 3
	assert.NoError(t, main.Migrate(connection, 3))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:793: 793-829 lines are duplicate of `migration_test.go:876-912` (dupl)
func Test0005MigrationStepUp(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("4")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultCreate := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedCreate := "CREATE TABLE IF NOT EXISTS read_errors .*"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedCreate).WillReturnResult(resultCreate)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 5
	assert.NoError(t, main.Migrate(connection, 5))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:876: 876-912 lines are duplicate of `migration_test.go:960-1004` (dupl)
func Test0005MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("5")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultDrop := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedDrop := "DROP TABLE read_errors"
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedDrop).WillReturnResult(resultDrop)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 4
	assert.NoError(t, main.Migrate(connection, 4))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:960: 960-1004 lines are duplicate of `migration_test.go:1058-1100` (dupl)
func Test0006MigrationStepUp(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("5")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultAlter := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedAlter := `
		    ALTER TABLE read_errors
		    DROP CONSTRAINT IF EXISTS read_errors_org_id_fkey,
		    DROP CONSTRAINT IF EXISTS read_errors_org_id_cluster_updated_at_fkey,
		    ADD CONSTRAINT  read_errors_org_id_cluster_updated_at_fkey
		       FOREIGN KEY \(org_id, cluster, updated_at\)
		       REFERENCES  new_reports\(org_id, cluster, updated_at\)
		       ON DELETE CASCADE;
		`
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedAlter).WillReturnResult(resultAlter)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 6
	assert.NoError(t, main.Migrate(connection, 6))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
migration_test.go:1058: 1058-1100 lines are duplicate of `migration_test.go:102-139` (dupl)
func Test0006MigrationStepDown(t *testing.T) {
	// prepare new mocked connection to database
	connection, mock := mustCreateMockConnection(t)

	// prepare mocked result for SQL query
	rows := sqlmock.NewRows([]string{"version"})
	rows.AddRow("6")

	count := sqlmock.NewRows([]string{"count"})
	count.AddRow("1")

	resultAlter := sqlmock.NewResult(0, 1)
	resultUpdate := sqlmock.NewResult(1, 1)

	// expected query performed by tested function
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	expectedQuery1 := "SELECT version FROM migration_info;"
	expectedAlter := `
		    ALTER TABLE read_errors
		    DROP CONSTRAINT read_errors_org_id_cluster_updated_at_fkey,
		    ADD CONSTRAINT  read_errors_org_id_cluster_updated_at_fkey
		       FOREIGN KEY \(org_id, cluster, updated_at\)
		       REFERENCES  new_reports\(org_id, cluster, updated_at\);
		`
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"

	mock.ExpectQuery(expectedQuery0).WillReturnRows(count)
	mock.ExpectQuery(expectedQuery1).WillReturnRows(rows)
	mock.ExpectBegin()
	mock.ExpectExec(expectedAlter).WillReturnResult(resultAlter)
	mock.ExpectExec(expectedUpdate).WillReturnResult(resultUpdate)
	mock.ExpectCommit()
	mock.ExpectClose()

	// prepare list of all migrations
	utils.Set(main.All())

	// migrate to version 5
	assert.NoError(t, main.Migrate(connection, 5))

	// check if all expectations were met
	checkAllExpectations(t, mock)
}
ccx_notification_writer.go:699:10: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"version out of range: %v\", vers)" (err113)
			err = fmt.Errorf("version out of range: %v", vers)
			      ^
config.go:222:25: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"fatal error config file: %s\", err)" (err113)
		return configuration, fmt.Errorf("fatal error config file: %s", err)
		                      ^
consumer.go:469:29: do not define dynamic errors, use wrapped static errors instead: "errors.New(errorMessage)" (err113)
		return message.RequestID, errors.New(errorMessage)
		                          ^
consumer.go:491:6: do not compare errors directly "err == ErrOldReport", use "errors.Is(err, ErrOldReport)" instead (err113)
		if err == ErrOldReport {
		   ^
consumer.go:555:11: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"Improper report structure, missing key \" + expectedKey)" (err113)
			return errors.New("Improper report structure, missing key " + expectedKey)
			       ^
consumer.go:572:24: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"missing required attribute 'OrgID'\")" (err113)
		return deserialized, errors.New("missing required attribute 'OrgID'")
		                     ^
consumer.go:575:24: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"missing required attribute 'AccountNumber'\")" (err113)
		return deserialized, errors.New("missing required attribute 'AccountNumber'")
		                     ^
consumer.go:578:24: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"missing required attribute 'ClusterName'\")" (err113)
		return deserialized, errors.New("missing required attribute 'ClusterName'")
		                     ^
consumer.go:581:24: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"missing required attribute 'Report'\")" (err113)
		return deserialized, errors.New("missing required attribute 'Report'")
		                     ^
consumer.go:587:24: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"cluster name is not a UUID\")" (err113)
		return deserialized, errors.New("cluster name is not a UUID")
		                     ^
logging_test.go:148:85: do not define dynamic errors, use wrapped static errors instead: "errors.New(testError)" (err113)
		main.LogMessageError(consumer, &originalMessage, parsedMessage, testEventMessage, errors.New(testError))
		                                                                                  ^
logging_test.go:173:78: do not define dynamic errors, use wrapped static errors instead: "errors.New(testError)" (err113)
		main.LogUnparsedMessageError(consumer, &originalMessage, testEventMessage, errors.New(testError))
		                                                                           ^
migration_test.go:41:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"mocked error\")" (err113)
	mockedError := errors.New("mocked error")
	               ^
migration_test.go:70:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"mocked error\")" (err113)
	mockedError := errors.New("mocked error")
	               ^
migration_test.go:145:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"mocked error\")" (err113)
	mockedError := errors.New("mocked error")
	               ^
storage.go:426:9: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"driver %v is not supported\", driverName)" (err113)
		err = fmt.Errorf("driver %v is not supported", driverName)
		      ^
storage.go:456:10: do not define dynamic errors, use wrapped static errors instead: "fmt.Errorf(\"writing report with DB %v is not supported\", storage.dbDriverType)" (err113)
		return fmt.Errorf("writing report with DB %v is not supported", storage.dbDriverType)
		       ^
storage_test.go:149:5: do not compare errors directly "err != mockedError", use "!errors.Is(err, mockedError)" instead (err113)
	if err != mockedError {
	   ^
storage_test.go:977:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"no such table: migration_info\")" (err113)
	noSuchTable := errors.New("no such table: migration_info")
	               ^
storage_test.go:1009:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"no such table: migration_info\")" (err113)
	noSuchTable := errors.New("no such table: migration_info")
	               ^
storage_test.go:1012:20: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"DROP table error\")" (err113)
	dropTableError := errors.New("DROP table error")
	                  ^
storage_test.go:1043:17: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"no such table: migration_info\")" (err113)
	noSuchTable := errors.New("no such table: migration_info")
	               ^
storage_test.go:1046:22: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"CREATE table error\")" (err113)
	createTableError := errors.New("CREATE table error")
	                    ^
storage_test.go:1082:26: do not define dynamic errors, use wrapped static errors instead: "errors.New(\"INSERT INTO table error\")" (err113)
	insertIntoTableError := errors.New("INSERT INTO table error")
	                        ^
config.go:199:27: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors (errorlint)
	if _, isNotFoundError := err.(viper.ConfigFileNotFoundError); !specified && isNotFoundError {
	                         ^
ccx_notification_writer.go:625:3: logger.KafkaZerologConfiguration is missing fields Broker, Topic, CertPath, Level (exhaustruct)
		logger.KafkaZerologConfiguration{},
		^
ccx_notification_writer_test.go:75:19: main.ConfigStruct is missing fields Broker, Storage, Logging, CloudWatchConf, Metrics, Tracker, Sentry (exhaustruct)
	configuration := main.ConfigStruct{}
	                 ^
ccx_notification_writer_test.go:76:25: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword, Group, Enabled (exhaustruct)
	configuration.Broker = main.BrokerConfiguration{
	                       ^
ccx_notification_writer_test.go:80:26: main.MetricsConfiguration is missing field Address (exhaustruct)
	configuration.Metrics = main.MetricsConfiguration{
	                        ^
ccx_notification_writer_test.go:104:19: main.ConfigStruct is missing fields Broker, Storage, Logging, CloudWatchConf, Metrics, Tracker, Sentry (exhaustruct)
	configuration := main.ConfigStruct{}
	                 ^
ccx_notification_writer_test.go:105:14: main.CliFlags is missing fields PerformDatabaseCleanup, PerformDatabaseInitialization, PerformDatabaseInitMigration, PerformDatabaseDropTables, CheckConnectionToKafka, PrintNewReportsForCleanup, PerformNewReportsCleanup, PrintOldReportsForCleanup, PerformOldReportsCleanup, PrintReadErrorsForCleanup, PerformReadErrorsCleanup, MigrationInfo, MaxAge, PerformMigrations, TruncateOldReports (exhaustruct)
	cliFlags := main.CliFlags{
	            ^
ccx_notification_writer_test.go:129:19: main.ConfigStruct is missing fields Broker, Storage, Logging, CloudWatchConf, Metrics, Tracker, Sentry (exhaustruct)
	configuration := main.ConfigStruct{}
	                 ^
ccx_notification_writer_test.go:130:14: main.CliFlags is missing fields PerformDatabaseCleanup, PerformDatabaseInitialization, PerformDatabaseInitMigration, PerformDatabaseDropTables, CheckConnectionToKafka, PrintNewReportsForCleanup, PerformNewReportsCleanup, PrintOldReportsForCleanup, PerformOldReportsCleanup, PrintReadErrorsForCleanup, PerformReadErrorsCleanup, MigrationInfo, MaxAge, PerformMigrations, TruncateOldReports (exhaustruct)
	cliFlags := main.CliFlags{
	            ^
ccx_notification_writer_test.go:156:25: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword, Group, Enabled (exhaustruct)
	configuration.Broker = main.BrokerConfiguration{
	                       ^
ccx_notification_writer_test.go:160:26: main.MetricsConfiguration is missing field Address (exhaustruct)
	configuration.Metrics = main.MetricsConfiguration{
	                        ^
ccx_notification_writer_test.go:164:14: main.CliFlags is missing fields PerformDatabaseCleanup, PerformDatabaseInitialization, PerformDatabaseInitMigration, PerformDatabaseDropTables, CheckConnectionToKafka, PrintNewReportsForCleanup, PerformNewReportsCleanup, PrintOldReportsForCleanup, PerformOldReportsCleanup, PrintReadErrorsForCleanup, PerformReadErrorsCleanup, MigrationInfo, MaxAge, PerformMigrations, TruncateOldReports (exhaustruct)
	cliFlags := main.CliFlags{
	            ^
ccx_notification_writer_test.go:254:25: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword, Group, Enabled (exhaustruct)
	configuration.Broker = main.BrokerConfiguration{
	                       ^
ccx_notification_writer_test.go:258:14: main.CliFlags is missing fields PerformDatabaseCleanup, PerformDatabaseInitialization, PerformDatabaseInitMigration, PerformDatabaseDropTables, ShowVersion, ShowAuthors, ShowConfiguration, PrintNewReportsForCleanup, PerformNewReportsCleanup, PrintOldReportsForCleanup, PerformOldReportsCleanup, PrintReadErrorsForCleanup, PerformReadErrorsCleanup, MigrationInfo, MaxAge, PerformMigrations, TruncateOldReports (exhaustruct)
	cliFlags := main.CliFlags{
	            ^
config_test.go:218:26: v1.AppConfig is missing fields BOPURL, Endpoints, FeatureFlags, Hostname, InMemoryDb, Kafka, Logging, Metadata, MetricsPath, MetricsPort, ObjectStore, PrivateEndpoints, PrivatePort, PublicPort, TlsCAPath, WebPort (exhaustruct)
	clowder.LoadedConfig = &clowder.AppConfig{
	                        ^
config_test.go:219:14: v1.DatabaseConfig is missing fields AdminPassword, AdminUsername, Hostname, Password, Port, RdsCa, SslMode, Username (exhaustruct)
		Database: &clowder.DatabaseConfig{
		           ^
config_test.go:247:26: v1.AppConfig is missing fields BOPURL, Endpoints, FeatureFlags, Hostname, InMemoryDb, Logging, Metadata, MetricsPath, MetricsPort, ObjectStore, PrivateEndpoints, PrivatePort, PublicPort, TlsCAPath, WebPort (exhaustruct)
	clowder.LoadedConfig = &clowder.AppConfig{
	                        ^
config_test.go:248:14: v1.DatabaseConfig is missing fields AdminPassword, AdminUsername, Hostname, Password, Port, RdsCa, SslMode, Username (exhaustruct)
		Database: &clowder.DatabaseConfig{
		           ^
config_test.go:251:11: v1.KafkaConfig is missing fields Brokers, Topics (exhaustruct)
		Kafka: &clowder.KafkaConfig{}, // no brokers in configuration
		        ^
config_test.go:283:3: v1.BrokerConfig is missing fields Authtype, Cacert, Hostname, Port, Sasl, SecurityProtocol (exhaustruct)
		{},
		^
config_test.go:287:26: v1.AppConfig is missing fields BOPURL, Endpoints, FeatureFlags, Hostname, InMemoryDb, Logging, Metadata, MetricsPath, MetricsPort, ObjectStore, PrivateEndpoints, PrivatePort, PublicPort, TlsCAPath, WebPort (exhaustruct)
	clowder.LoadedConfig = &clowder.AppConfig{
	                        ^
config_test.go:288:14: v1.DatabaseConfig is missing fields AdminPassword, AdminUsername, Hostname, Password, Port, RdsCa, SslMode, Username (exhaustruct)
		Database: &clowder.DatabaseConfig{
		           ^
config_test.go:327:3: v1.BrokerConfig is missing fields Authtype, Cacert, Sasl, SecurityProtocol (exhaustruct)
		{
		^
config_test.go:333:26: v1.AppConfig is missing fields BOPURL, Endpoints, FeatureFlags, Hostname, InMemoryDb, Logging, Metadata, MetricsPath, MetricsPort, ObjectStore, PrivateEndpoints, PrivatePort, PublicPort, TlsCAPath, WebPort (exhaustruct)
	clowder.LoadedConfig = &clowder.AppConfig{
	                        ^
config_test.go:337:11: v1.KafkaConfig is missing field Topics (exhaustruct)
		Kafka: &clowder.KafkaConfig{
		        ^
config_test.go:372:3: v1.BrokerConfig is missing fields Authtype, Cacert, Sasl, SecurityProtocol (exhaustruct)
		{
		^
config_test.go:382:11: v1.KafkaConfig is missing field Topics (exhaustruct)
		Kafka: &clowder.KafkaConfig{
		        ^
config_test.go:417:3: v1.BrokerConfig is missing fields Cacert, Sasl, SecurityProtocol (exhaustruct)
		{
		^
config_test.go:429:11: v1.KafkaConfig is missing field Topics (exhaustruct)
		Kafka: &clowder.KafkaConfig{
		        ^
config_test.go:476:3: v1.BrokerConfig is missing field Cacert (exhaustruct)
		{
		^
config_test.go:482:11: v1.KafkaSASLConfig is missing field SecurityProtocol (exhaustruct)
			Sasl: &clowder.KafkaSASLConfig{
			       ^
config_test.go:538:26: v1.AppConfig is missing fields BOPURL, Database, Endpoints, FeatureFlags, Hostname, InMemoryDb, Logging, Metadata, MetricsPath, MetricsPort, ObjectStore, PrivateEndpoints, PrivatePort, PublicPort, TlsCAPath, WebPort (exhaustruct)
	clowder.LoadedConfig = &clowder.AppConfig{
	                        ^
config_test.go:541:5: v1.BrokerConfig is missing fields Authtype, Cacert, Sasl, SecurityProtocol (exhaustruct)
				{
				^
consumer.go:165:15: main.KafkaConsumer is missing fields Tracker, Cancel (exhaustruct)
	consumer := &KafkaConsumer{
	             ^
consumer.go:634:13: main.SCRAMClient is missing fields Client, ClientConversation (exhaustruct)
				return &SCRAMClient{HashGeneratorFcn: sha512.New}
				        ^
consumer_test.go:65:28: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:98:28: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:131:28: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:164:28: main.BrokerConfiguration is missing fields CertPath, SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:198:28: main.BrokerConfiguration is missing field CertPath (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:231:28: main.BrokerConfiguration is missing field CertPath (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:255:28: main.BrokerConfiguration is missing field CertPath (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:343:28: main.BrokerConfiguration is missing fields SecurityProtocol, SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:377:28: main.BrokerConfiguration is missing fields SaslMechanism, SaslUsername, SaslPassword (exhaustruct)
	var brokerConfiguration = main.BrokerConfiguration{
	                          ^
consumer_test.go:650:15: main.BrokerConfiguration is missing fields SecurityProtocol, CertPath, SaslMechanism, SaslUsername, SaslPassword, Enabled (exhaustruct)
	brokerCfg := main.BrokerConfiguration{
	             ^
consumer_test.go:655:10: main.KafkaConsumer is missing fields ConsumerGroup, Tracker, Cancel (exhaustruct)
	return &main.KafkaConsumer{
	        ^
consumer_test.go:676:13: sarama.ConsumerMessage is missing fields Headers, Timestamp, BlockTimestamp, Key, Value, Topic, Partition, Offset (exhaustruct)
	message := sarama.ConsumerMessage{}
	           ^
kafka_producer.go:115:18: sarama.ProducerMessage is missing fields Key, Headers, Metadata, Offset, Partition, Timestamp (exhaustruct)
	producerMsg := &sarama.ProducerMessage{
	                ^
metrics.go:127:41: prometheus.CounterOpts is missing fields Subsystem, ConstLabels (exhaustruct)
	ConsumedMessages = promauto.NewCounter(prometheus.CounterOpts{
	                                       ^
metrics.go:133:40: prometheus.CounterOpts is missing fields Subsystem, ConstLabels (exhaustruct)
	ConsumingErrors = promauto.NewCounter(prometheus.CounterOpts{
	                                      ^
metrics.go:139:46: prometheus.CounterOpts is missing fields Subsystem, ConstLabels (exhaustruct)
	ParsedIncomingMessage = promauto.NewCounter(prometheus.CounterOpts{
	                                            ^
ccx_notification_writer.go:123:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(versionMessage)
	^
ccx_notification_writer.go:128:2: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	fmt.Println(authorsMessage)
	^
ccx_notification_writer_test.go:93:2: use of `print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	print(output)
	^
config.go:296:4: use of `fmt.Println` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
			fmt.Println("kafka is configured to use authentication")
			^
config.go:347:3: use of `fmt.Printf` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
		fmt.Printf(noTopicMapping, configuration.Topic)
		^
config_test.go:311:2: use of `print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	print(clowder.KafkaServers)
	^
config_test.go:312:2: use of `print` forbidden by pattern `^(fmt\.Print(|f|ln)|print|println)$` (forbidigo)
	print(clowder.LoadedConfig.Kafka)
	^
consumer.go:400:32: Function 'ProcessMessage' has too many statements (58 > 40) (funlen)
func (consumer *KafkaConsumer) ProcessMessage(msg *sarama.ConsumerMessage) (types.RequestID, error) {
                               ^
metrics.go:114:6: Function 'AddMetricsWithNamespace' is too long (62 > 60) (funlen)
func AddMetricsWithNamespace(namespace string) {
     ^
consumer.go:133:5: DefaultSaramaConfig is a global variable (gochecknoglobals)
var DefaultSaramaConfig *sarama.Config
    ^
consumer_test.go:52:2: ExpectedOrgID is a global variable (gochecknoglobals)
	ExpectedOrgID         = types.OrgID(1)
	^
consumer_test.go:53:2: ExpectedAccountNumber is a global variable (gochecknoglobals)
	ExpectedAccountNumber = types.AccountNumber(1234)
	^
consumer_test.go:54:2: ExpectedClusterName is a global variable (gochecknoglobals)
	ExpectedClusterName   = types.ClusterName("84f7eedc-0dd8-49cd-9d4d-f6646df3a5bc")
	^
consumer_test.go:55:2: LastCheckedAt is a global variable (gochecknoglobals)
	LastCheckedAt         = time.Unix(25, 0).UTC()
	^
db_benchmark_test.go:243:5: minReportsParam is a global variable (gochecknoglobals)
var minReportsParam = flag.Int("min-reports", 1, "minimal number of reports to be inserted into database (inclusive)")
    ^
db_benchmark_test.go:244:5: maxReportsParam is a global variable (gochecknoglobals)
var maxReportsParam = flag.Int("max-reports", 10, "maximal number of reports to be inserted into database (exclusive)")
    ^
db_benchmark_test.go:245:5: reportsStepParam is a global variable (gochecknoglobals)
var reportsStepParam = flag.Int("reports-step", 1, "steps between consecutive reports count")
    ^
db_benchmark_test.go:246:5: reportsCountParam is a global variable (gochecknoglobals)
var reportsCountParam = flag.String("reports-count", "", "explicit reports count")
    ^
db_benchmark_test.go:298:5: connection is a global variable (gochecknoglobals)
var connection *sql.DB
    ^
db_benchmark_test.go:299:5: initialized is a global variable (gochecknoglobals)
var initialized = false
    ^
mig_0001_create_events_targets_tbl.go:36:5: mig0001CreateEventTargetsTbl is a global variable (gochecknoglobals)
var mig0001CreateEventTargetsTbl = mig.Migration{
    ^
mig_0002_add_event_target_col.go:36:5: mig0002AddEventTargetCol is a global variable (gochecknoglobals)
var mig0002AddEventTargetCol = mig.Migration{
    ^
mig_0003_populate_event_tables.go:40:5: mig0003PopulateEventTables is a global variable (gochecknoglobals)
var mig0003PopulateEventTables = mig.Migration{
    ^
mig_0004_update_reported_table_with_eventtype.go:36:5: mig0004UpdateEventTypeIDInReportedTable is a global variable (gochecknoglobals)
var mig0004UpdateEventTypeIDInReportedTable = mig.Migration{
    ^
mig_0005_create_read_errors_table.go:36:5: mig0005CreateReadErrorsTable is a global variable (gochecknoglobals)
var mig0005CreateReadErrorsTable = mig.Migration{
    ^
mig_0006_on_delete_cascade_from_errors_table.go:36:5: mig0006OnCascadeDeleteFromErrorsTable is a global variable (gochecknoglobals)
var mig0006OnCascadeDeleteFromErrorsTable = mig.Migration{
    ^
mig_0007_tables_description.go:35:5: mig0007TablesDescription is a global variable (gochecknoglobals)
var mig0007TablesDescription = mig.Migration{
    ^
migration.go:36:5: migrations is a global variable (gochecknoglobals)
var migrations = []utils.Migration{
    ^
storage.go:332:5: tableNames is a global variable (gochecknoglobals)
var tableNames []string
    ^
storage.go:335:5: initStatements is a global variable (gochecknoglobals)
var initStatements []string
    ^
ccx_notification_writer_test.go:38:1: don't use `init` function (gochecknoinits)
func init() {
^
config_test.go:39:1: don't use `init` function (gochecknoinits)
func init() {
^
kafka_producer_test.go:44:1: don't use `init` function (gochecknoinits)
func init() {
^
config_test.go:123:12: string `CCX_NOTIFICATION_WRITER_CONFIG_FILE` has 9 occurrences, but such constant `configFileEnvName` already exists (goconst)
	envVar := "CCX_NOTIFICATION_WRITER_CONFIG_FILE"
	          ^
migration_test.go:47:20: string `SELECT COUNT\(\*\) FROM migration_info;` has 30 occurrences, make it a constant (goconst)
	expectedQuery0 := "SELECT COUNT\\(\\*\\) FROM migration_info;"
	                  ^
migration_test.go:81:20: string `SELECT version FROM migration_info;` has 29 occurrences, make it a constant (goconst)
	expectedQuery1 := "SELECT version FROM migration_info;"
	                  ^
migration_test.go:120:20: string `CREATE TABLE IF NOT EXISTS event_targets .*` has 5 occurrences, make it a constant (goconst)
	expectedCreate := "CREATE TABLE IF NOT EXISTS event_targets .*"
	                  ^
migration_test.go:121:20: string `UPDATE migration_info SET version=\$1;` has 14 occurrences, make it a constant (goconst)
	expectedUpdate := "UPDATE migration_info SET version=\\$1;"
	                  ^
migration_test.go:290:19: string `ALTER TABLE reported ADD COLUMN .*` has 4 occurrences, make it a constant (goconst)
	expectedAlter := "ALTER TABLE reported ADD COLUMN .*"
	                 ^
storage_test.go:172:19: string `SELECT org_id, account_number, cluster, updated_at, kafka_offset FROM new_reports WHERE updated_at < NOW\(\) - \$1::INTERVAL ORDER BY updated_at` has 3 occurrences, make it a constant (goconst)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, kafka_offset FROM new_reports WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
	                 ^
storage_test.go:272:19: string `SELECT org_id, account_number, cluster, updated_at, 0 FROM reported WHERE updated_at < NOW\(\) - \$1::INTERVAL ORDER BY updated_at` has 3 occurrences, make it a constant (goconst)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, 0 FROM reported WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
	                 ^
storage_test.go:1188:19: string `SELECT org_id, 0, cluster, updated_at, 0 FROM read_errors WHERE updated_at < NOW\(\) - \$1::INTERVAL ORDER BY updated_at` has 3 occurrences, make it a constant (goconst)
	expectedQuery := "SELECT org_id, 0, cluster, updated_at, 0 FROM read_errors WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
	                 ^
ccx_notification_writer.go:66:1: Comment should end in a period (godot)
// Messages to be displayed on terminal or written into logs
^
ccx_notification_writer.go:90:1: Comment should end in a period (godot)
// Configuration-related constants
^
ccx_notification_writer.go:92:2: Comment should end in a period (godot)
	// environment variable that might contain name of configuration file
	^
ccx_notification_writer.go:570:2: ccx_notification_writer.go:570: Line contains TODO/BUG/FIXME: "TODO: refactor utils/logger appropriatel..." (godox)
// TODO: refactor utils/logger appropriately
 ^
consumer.go:83:2: consumer.go:83: Line contains TODO/BUG/FIXME: "TODO: make this value configurable" (godox)
// TODO: make this value configurable
 ^
consumer.go:606:3: consumer.go:606: Line contains TODO/BUG/FIXME: "TODO: we need to do it in production cod..." (godox)
	/* TODO: we need to do it in production code
	 ^
types.go:61:2: types.go:61: Line contains TODO/BUG/FIXME: "TODO: provide expected schema version in..." (godox)
// TODO: provide expected schema version in configuration file
 ^
db_benchmark_test.go:504:18: G304: Potential file inclusion via variable (gosec)
	content, err := os.ReadFile(reportDirectory + filename)
	                ^
storage.go:294:14: the interface has more than 10 methods: 14 (interfacebloat)
type Storage interface {
             ^
storage_test.go:45:1: mustCreateMockConnection returns interface (github.com/DATA-DOG/go-sqlmock.Sqlmock) (ireturn)
func mustCreateMockConnection(t *testing.T) (*sql.DB, sqlmock.Sqlmock) {
^
ccx_notification_writer.go:602:1: The line is 128 characters long, which exceeds the maximum of 120 characters. (lll)
	flag.BoolVar(&cliFlags.PrintNewReportsForCleanup, "print-new-reports-for-cleanup", false, "print new reports to be cleaned up")
^
ccx_notification_writer.go:604:1: The line is 128 characters long, which exceeds the maximum of 120 characters. (lll)
	flag.BoolVar(&cliFlags.PrintOldReportsForCleanup, "print-old-reports-for-cleanup", false, "print old reports to be cleaned up")
^
ccx_notification_writer.go:606:1: The line is 147 characters long, which exceeds the maximum of 120 characters. (lll)
	flag.BoolVar(&cliFlags.PrintReadErrorsForCleanup, "print-read-errors-for-cleanup", false, "print records from read_errors table to be cleaned up")
^
consumer.go:159:1: The line is 138 characters long, which exceeds the maximum of 120 characters. (lll)
	consumerGroup, err := sarama.NewConsumerGroup(strings.Split(brokerConfiguration.Addresses, ","), brokerConfiguration.Group, saramaConfig)
^
consumer.go:234:1: The line is 121 characters long, which exceeds the maximum of 120 characters. (lll)
func (consumer *KafkaConsumer) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
^
consumer_test.go:247:1: The line is 137 characters long, which exceeds the maximum of 120 characters. (lll)
	assert.Nil(t, saramaConfig.Net.SASL.SCRAMClientGeneratorFunc, "SCRAM client generator function should not be created with given config")
^
consumer_test.go:271:1: The line is 143 characters long, which exceeds the maximum of 120 characters. (lll)
	assert.NotNil(t, saramaConfig.Net.SASL.SCRAMClientGeneratorFunc, "SCRAM client generator function should have been created with given config")
^
consumer_test.go:295:1: The line is 137 characters long, which exceeds the maximum of 120 characters. (lll)
	assert.Nil(t, saramaConfig.Net.SASL.SCRAMClientGeneratorFunc, "SCRAM client generator function should not be created with given config")
^
consumer_test.go:722:1: The line is 152 characters long, which exceeds the maximum of 120 characters. (lll)
	assert.EqualError(t, err, "parsing time \"2020.01.23 16:15:59\" as \"2006-01-02T15:04:05.999999999Z07:00\": cannot parse \".01.23 16:15:59\" as \"-\"")
^
db_benchmark_test.go:201:1: The line is 130 characters long, which exceeds the maximum of 120 characters. (lll)
            (org_id, account_number, cluster, notification_type, state, report, updated_at, notified_at, error_log, event_type_id)
^
logging.go:36:1: The line is 132 characters long, which exceeds the maximum of 120 characters. (lll)
func logMessageInfo(consumer *KafkaConsumer, originalMessage *sarama.ConsumerMessage, parsedMessage IncomingMessage, event string) {
^
logging.go:49:1: The line is 121 characters long, which exceeds the maximum of 120 characters. (lll)
func logUnparsedMessageError(consumer *KafkaConsumer, originalMessage *sarama.ConsumerMessage, event string, err error) {
^
logging.go:59:1: The line is 144 characters long, which exceeds the maximum of 120 characters. (lll)
func logMessageError(consumer *KafkaConsumer, originalMessage *sarama.ConsumerMessage, parsedMessage IncomingMessage, event string, err error) {
^
logging.go:72:1: The line is 135 characters long, which exceeds the maximum of 120 characters. (lll)
func logMessageWarning(consumer *KafkaConsumer, originalMessage *sarama.ConsumerMessage, parsedMessage IncomingMessage, event string) {
^
mock_storage_test.go:79:1: The line is 173 characters long, which exceeds the maximum of 120 characters. (lll)
func (storage *MockStorage) WriteReportForCluster(_ types.OrgID, _ types.AccountNumber, _ types.ClusterName, _ types.ClusterReport, _ time.Time, _ types.KafkaOffset) error {
^
storage.go:408:1: The line is 124 characters long, which exceeds the maximum of 120 characters. (lll)
func initAndGetDriver(configuration *StorageConfiguration) (driverType DBDriver, driverName, dataSource string, err error) {
^
storage_test.go:206:1: The line is 167 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, kafka_offset FROM new_reports WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
storage_test.go:238:1: The line is 167 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, kafka_offset FROM new_reports WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
storage_test.go:306:1: The line is 153 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, 0 FROM reported WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
storage_test.go:338:1: The line is 153 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, account_number, cluster, updated_at, 0 FROM reported WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
storage_test.go:497:1: The line is 167 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedStatement := "INSERT INTO new_reports\\(org_id, account_number, cluster, report, updated_at, kafka_offset\\) VALUES \\(\\$1, \\$2, \\$3, \\$4, \\$5, \\$6\\);"
^
storage_test.go:988:1: The line is 137 characters long, which exceeds the maximum of 120 characters. (lll)
	mock.ExpectExec("CREATE TABLE IF NOT EXISTS migration_info \\( version integer not null \\);").WillReturnResult(sqlmock.NewResult(1, 1))
^
storage_test.go:1057:1: The line is 129 characters long, which exceeds the maximum of 120 characters. (lll)
	mock.ExpectExec("CREATE TABLE IF NOT EXISTS migration_info \\( version integer not null \\);").WillReturnError(createTableError)
^
storage_test.go:1222:1: The line is 143 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, 0, cluster, updated_at, 0 FROM read_errors WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
storage_test.go:1254:1: The line is 143 characters long, which exceeds the maximum of 120 characters. (lll)
	expectedQuery := "SELECT org_id, 0, cluster, updated_at, 0 FROM read_errors WHERE updated_at < NOW\\(\\) - \\$1::INTERVAL ORDER BY updated_at"
^
db_benchmark_test.go:606:20: append to slice `sqlStatements` with non-zero initialized length (makezero)
			sqlStatements = append(sqlStatements, initStatements...)
			                ^
db_benchmark_test.go:609:20: append to slice `sqlStatements` with non-zero initialized length (makezero)
			sqlStatements = append(sqlStatements, indexStatements...)
			                ^
db_benchmark_test.go:641:21: append to slice `sqlStatements` with non-zero initialized length (makezero)
				sqlStatements = append(sqlStatements, initStatements...)
				                ^
logging_test.go:109:22: `writen` is a misspelling of `written` (misspell)
	// expected text(s) writen onto error output
	                    ^
logging_test.go:130:22: `writen` is a misspelling of `written` (misspell)
	// expected text(s) writen onto error output
	                    ^
logging_test.go:154:22: `writen` is a misspelling of `written` (misspell)
	// expected text(s) writen onto error output
	                    ^
storage_test.go:958:27: `commited` is a misspelling of `committed` (misspell)
	// transaction should be commited
	                         ^
storage_test.go:991:27: `commited` is a misspelling of `committed` (misspell)
	// transaction should be commited
	                         ^
consumer.go:528:16: Magic number: 100.0, in <operation> detected (mnd)
	percentage := 100.0 * shrunk / orig
	              ^
storage.go:733:53: Magic number: 24, in <argument> detected (mnd)
		age := int(math.Ceil(now.Sub(updatedAt).Hours() / 24)) // in days
		                                                  ^
ccx_notification_writer.go:681:3: naked return in func `PerformMigrations` with 44 lines of code (nakedret)
		return
		^
ccx_notification_writer.go:694:4: naked return in func `PerformMigrations` with 44 lines of code (nakedret)
			return
			^
ccx_notification_writer.go:700:4: naked return in func `PerformMigrations` with 44 lines of code (nakedret)
			return
			^
config.go:281:1: `if len(clowder.LoadedConfig.Kafka.Brokers) > 0` has complex nested blocks (complexity: 10) (nestif)
	if len(clowder.LoadedConfig.Kafka.Brokers) > 0 {
^
ccx_notification_writer.go:197:4: continue with no blank line before (nlreturn)
			continue
			^
ccx_notification_writer.go:204:4: continue with no blank line before (nlreturn)
			continue
			^
ccx_notification_writer.go:208:4: continue with no blank line before (nlreturn)
			continue
			^
ccx_notification_writer.go:218:2: return with no blank line before (nlreturn)
	return ExitStatusKafkaError, err
	^
ccx_notification_writer.go:230:3: return with no blank line before (nlreturn)
		return ExitStatusStorageError, err
		^
ccx_notification_writer.go:237:3: return with no blank line before (nlreturn)
		return ExitStatusStorageError, err
		^
db_benchmark_test.go:671:1: directive `//nolint:prealloc` is unused for linter "prealloc" (nolintlint)
//nolint:prealloc
^
ccx_notification_writer.go:671:1: named return "exitStatus" with type "int" found (nonamedreturns)
func PerformMigrations(configuration *ConfigStruct, migParam string) (exitStatus int, err error) {
^
kafka_producer.go:108:1: named return "partitionID" with type "int32" found (nonamedreturns)
func (producer *Producer) ProduceMessage(msg []byte) (partitionID int32, offset int64, err error) {
^
scram_client.go:13:1: named return "err" with type "error" found (nonamedreturns)
func (x *SCRAMClient) Begin(userName, password, authzID string) (err error) {
^
scram_client.go:23:1: named return "response" with type "string" found (nonamedreturns)
func (x *SCRAMClient) Step(challenge string) (response string, err error) {
^
ccx_notification_writer_test.go:44:1: Function TestShowVersion missing the call to method parallel (paralleltest)
func TestShowVersion(t *testing.T) {
^
ccx_notification_writer_test.go:58:1: Function TestShowAuthors missing the call to method parallel (paralleltest)
func TestShowAuthors(t *testing.T) {
^
ccx_notification_writer_test.go:73:1: Function TestShowConfiguration missing the call to method parallel (paralleltest)
func TestShowConfiguration(t *testing.T) {
^
ccx_notification_writer_test.go:102:1: Function TestDoSelectedOperationShowVersion missing the call to method parallel (paralleltest)
func TestDoSelectedOperationShowVersion(t *testing.T) {
^
ccx_notification_writer_test.go:127:1: Function TestDoSelectedOperationShowAuthors missing the call to method parallel (paralleltest)
func TestDoSelectedOperationShowAuthors(t *testing.T) {
^
ccx_notification_writer_test.go:153:1: Function TestDoSelectedOperationShowConfiguration missing the call to method parallel (paralleltest)
func TestDoSelectedOperationShowConfiguration(t *testing.T) {
^
ccx_notification_writer_test.go:188:1: Function TestConvertLogLevel missing the call to method parallel (paralleltest)
func TestConvertLogLevel(t *testing.T) {
^
ccx_notification_writer_test.go:251:1: Function TestDoSelectedOperationCheckConnectionToKafka missing the call to method parallel (paralleltest)
func TestDoSelectedOperationCheckConnectionToKafka(t *testing.T) {
^
config_test.go:65:1: Function TestLoadDefaultConfiguration missing the call to method parallel (paralleltest)
func TestLoadDefaultConfiguration(_ *testing.T) {
^
config_test.go:72:1: Function TestLoadConfigurationFromEnvVariable missing the call to method parallel (paralleltest)
func TestLoadConfigurationFromEnvVariable(t *testing.T) {
^
config_test.go:83:1: Function TestLoadConfigurationNonEnvVarUnknownConfigFile missing the call to method parallel (paralleltest)
func TestLoadConfigurationNonEnvVarUnknownConfigFile(t *testing.T) {
^
config_test.go:90:1: Function TestLoadConfigurationBadConfigFile missing the call to method parallel (paralleltest)
func TestLoadConfigurationBadConfigFile(t *testing.T) {
^
config_test.go:97:1: Function TestLoadingConfigurationEnvVariableBadValueNoDefaultConfig missing the call to method parallel (paralleltest)
func TestLoadingConfigurationEnvVariableBadValueNoDefaultConfig(t *testing.T) {
^
config_test.go:110:1: Function TestLoadingConfigurationEnvVariableBadValueDefaultConfigFailure missing the call to method parallel (paralleltest)
func TestLoadingConfigurationEnvVariableBadValueDefaultConfigFailure(t *testing.T) {
^
config_test.go:122:1: Function TestLoadBrokerConfiguration missing the call to method parallel (paralleltest)
func TestLoadBrokerConfiguration(t *testing.T) {
^
config_test.go:138:1: Function TestLoadStorageConfiguration missing the call to method parallel (paralleltest)
func TestLoadStorageConfiguration(t *testing.T) {
^
config_test.go:160:1: Function TestLoadLoggingConfiguration missing the call to method parallel (paralleltest)
func TestLoadLoggingConfiguration(t *testing.T) {
^
config_test.go:176:1: Function TestLoadCloudwatchConfiguration missing the call to method parallel (paralleltest)
func TestLoadCloudwatchConfiguration(t *testing.T) {
^
config_test.go:195:1: Function TestLoadMetricsConfiguration missing the call to method parallel (paralleltest)
func TestLoadMetricsConfiguration(t *testing.T) {
^
config_test.go:213:1: Function TestLoadConfigurationFromEnvVariableClowderEnabled missing the call to method parallel (paralleltest)
func TestLoadConfigurationFromEnvVariableClowderEnabled(t *testing.T) {
^
config_test.go:242:1: Function TestLoadConfigurationNoKafkaBroker missing the call to method parallel (paralleltest)
func TestLoadConfigurationNoKafkaBroker(t *testing.T) {
^
config_test.go:277:1: Function TestLoadConfigurationKafkaBrokerEmptyConfig missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaBrokerEmptyConfig(t *testing.T) {
^
config_test.go:321:1: Function TestLoadConfigurationKafkaBrokerNoPort missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaBrokerNoPort(t *testing.T) {
^
config_test.go:364:1: Function TestLoadConfigurationKafkaBrokerPort missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaBrokerPort(t *testing.T) {
^
config_test.go:409:1: Function TestLoadConfigurationKafkaBrokerAuthConfigMissingSASL missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaBrokerAuthConfigMissingSASL(t *testing.T) {
^
config_test.go:463:1: Function TestLoadConfigurationKafkaBrokerAuthConfig missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaBrokerAuthConfig(t *testing.T) {
^
config_test.go:530:1: Function TestLoadConfigurationKafkaTopicUpdatedFromClowder missing the call to method parallel (paralleltest)
func TestLoadConfigurationKafkaTopicUpdatedFromClowder(t *testing.T) {
^
config_test.go:578:1: Function TestGetStorageConfigurationIsImmutable missing the call to method parallel (paralleltest)
func TestGetStorageConfigurationIsImmutable(t *testing.T) {
^
config_test.go:601:1: Function TestGetLoggingConfigurationIsImmutable missing the call to method parallel (paralleltest)
func TestGetLoggingConfigurationIsImmutable(t *testing.T) {
^
config_test.go:624:1: Function TestGetBrokerConfigurationIsImmutable missing the call to method parallel (paralleltest)
func TestGetBrokerConfigurationIsImmutable(t *testing.T) {
^
config_test.go:647:1: Function TestGetMetricsConfigurationIsImmutable missing the call to method parallel (paralleltest)
func TestGetMetricsConfigurationIsImmutable(t *testing.T) {
^
consumer_test.go:60:1: Function TestNewConsumerBadBrokerNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerBadBrokerNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:93:1: Function TestNewConsumerLocalBrokerNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerLocalBrokerNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:126:1: Function TestNewConsumerSaramaConfigNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerSaramaConfigNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:159:1: Function TestNewConsumerTLSEnabledNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerTLSEnabledNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:193:1: Function TestNewConsumerSASLEnabledNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerSASLEnabledNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:229:1: Function TestSaramaConfigFromBrokerWithSASLEnabledNoSASLMechanism missing the call to method parallel (paralleltest)
func TestSaramaConfigFromBrokerWithSASLEnabledNoSASLMechanism(t *testing.T) {
^
consumer_test.go:253:1: Function TestSaramaConfigFromBrokerWithSASLEnabledSCRAMAuth missing the call to method parallel (paralleltest)
func TestSaramaConfigFromBrokerWithSASLEnabledSCRAMAuth(t *testing.T) {
^
consumer_test.go:277:1: Function TestSaramaConfigFromBrokerWithSASLEnabledUnexpectedAuthMechanism missing the call to method parallel (paralleltest)
func TestSaramaConfigFromBrokerWithSASLEnabledUnexpectedAuthMechanism(t *testing.T) {
^
consumer_test.go:301:1: Function TestNewConsumerSASLEnabled missing the call to method parallel (paralleltest)
func TestNewConsumerSASLEnabled(t *testing.T) {
^
consumer_test.go:338:1: Function TestNewConsumerCertPathNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerCertPathNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:372:1: Function TestNewConsumerInvalidCertPathNonAccessibleBroker missing the call to method parallel (paralleltest)
func TestNewConsumerInvalidCertPathNonAccessibleBroker(t *testing.T) {
^
consumer_test.go:406:1: Function TestParseEmptyMessage missing the call to method parallel (paralleltest)
func TestParseEmptyMessage(t *testing.T) {
^
consumer_test.go:419:1: Function TestParseMessageWithWrongContent missing the call to method parallel (paralleltest)
func TestParseMessageWithWrongContent(t *testing.T) {
^
consumer_test.go:433:1: Function TestParseMessageWithImproperJSON missing the call to method parallel (paralleltest)
func TestParseMessageWithImproperJSON(t *testing.T) {
^
consumer_test.go:450:1: Function TestParseProperMessage missing the call to method parallel (paralleltest)
func TestParseProperMessage(t *testing.T) {
^
consumer_test.go:474:1: Function TestParseProperMessageWrongOrgID missing the call to method parallel (paralleltest)
func TestParseProperMessageWrongOrgID(t *testing.T) {
^
consumer_test.go:497:1: Function TestParseProperMessageWrongAccountNumber missing the call to method parallel (paralleltest)
func TestParseProperMessageWrongAccountNumber(t *testing.T) {
^
consumer_test.go:520:1: Function TestParseProperMessageWrongClusterName missing the call to method parallel (paralleltest)
func TestParseProperMessageWrongClusterName(t *testing.T) {
^
consumer_test.go:539:1: Function TestParseMessageWithoutOrgID missing the call to method parallel (paralleltest)
func TestParseMessageWithoutOrgID(t *testing.T) {
^
db_benchmark_test.go:657:20: param min has same name as predeclared identifier (predeclared)
func computeLength(min, max, step int) int {
                   ^
metrics.go:60:44: Metric: consumed_messages Error: counter metrics should have "_total" suffix (promlinter)
var ConsumedMessages = promauto.NewCounter(prometheus.CounterOpts{
                                           ^
metrics.go:66:43: Metric: consuming_errors Error: counter metrics should have "_total" suffix (promlinter)
var ConsumingErrors = promauto.NewCounter(prometheus.CounterOpts{
                                          ^
metrics.go:72:49: Metric: parse_incoming_message Error: counter metrics should have "_total" suffix (promlinter)
var ParsedIncomingMessage = promauto.NewCounter(prometheus.CounterOpts{
                                                ^
metrics.go:78:46: Metric: check_schema_version Error: counter metrics should have "_total" suffix (promlinter)
var CheckSchemaVersion = promauto.NewCounter(prometheus.CounterOpts{
                                             ^
metrics.go:84:41: Metric: marshal_report Error: counter metrics should have "_total" suffix (promlinter)
var MarshalReport = promauto.NewCounter(prometheus.CounterOpts{
                                        ^
metrics.go:90:40: Metric: shrink_report Error: counter metrics should have "_total" suffix (promlinter)
var ShrinkReport = promauto.NewCounter(prometheus.CounterOpts{
                                       ^
metrics.go:96:53: Metric: check_last_checked_timestamp Error: counter metrics should have "_total" suffix (promlinter)
var CheckLastCheckedTimestamp = promauto.NewCounter(prometheus.CounterOpts{
                                                    ^
metrics.go:102:42: Metric: stored_messages Error: counter metrics should have "_total" suffix (promlinter)
var StoredMessages = promauto.NewCounter(prometheus.CounterOpts{
                                         ^
metrics.go:108:39: Metric: stored_bytes Error: counter metrics should have "_total" suffix (promlinter)
var StoredBytes = promauto.NewCounter(prometheus.CounterOpts{
                                      ^
mig_0002_add_event_target_col.go:52:29: unused-parameter: parameter 'driver' seems to be unused, consider removing or renaming it as _ (revive)
	StepDown: func(tx *sql.Tx, driver types.DBDriver) error {
	                           ^
db_benchmark_test.go:472:33: rows.Err must be checked (rowserrcheck)
			rows, err := connection.Query(selectStatement, "8 days")
			                             ^
storage.go:706:39: rows.Err must be checked (rowserrcheck)
	rows, err := storage.connection.Query(query, maxAge)
	                                     ^
db_benchmark_test.go:480:20: Close should use defer (sqlclosecheck)
			err = rows.Close()
			                ^
storage.go:726:29: Close should use defer (sqlclosecheck)
			if closeErr := rows.Close(); closeErr != nil {
			                         ^
config_test.go:371:20: ST1023: should omit type []clowder.BrokerConfig from declaration; it will be inferred from the right-hand side (staticcheck)
	var brokersConfig []clowder.BrokerConfig = []clowder.BrokerConfig{
	                  ^
config_test.go:416:20: ST1023: should omit type []clowder.BrokerConfig from declaration; it will be inferred from the right-hand side (staticcheck)
	var brokersConfig []clowder.BrokerConfig = []clowder.BrokerConfig{
	                  ^
config_test.go:475:20: ST1023: should omit type []clowder.BrokerConfig from declaration; it will be inferred from the right-hand side (staticcheck)
	var brokersConfig []clowder.BrokerConfig = []clowder.BrokerConfig{
	                  ^
kafka_producer.go:160:23: QF1008: could remove embedded field "Producer" from selector (staticcheck)
	_, _, err = producer.Producer.ProduceMessage(jsonBytes)
	                     ^
logging_test.go:84:12: ST1023: should omit type types.OrgID from declaration; it will be inferred from the right-hand side (staticcheck)
	var orgID types.OrgID = types.OrgID(testOrganizationID)
	          ^
logging_test.go:85:18: ST1023: should omit type types.ClusterName from declaration; it will be inferred from the right-hand side (staticcheck)
	var clusterName types.ClusterName = types.ClusterName(testClusterName)
	                ^
scram_client.go:14:20: QF1008: could remove embedded field "HashGeneratorFcn" from selector (staticcheck)
	x.Client, err = x.HashGeneratorFcn.NewClient(userName, password, authzID)
	                  ^
scram_client.go:18:27: QF1008: could remove embedded field "Client" from selector (staticcheck)
	x.ClientConversation = x.Client.NewConversation()
	                         ^
config.go:119:51: tag is not aligned, should be: mapstructure:"broker"     toml:"broker" (tagalign)
	Broker         BrokerConfiguration               `mapstructure:"broker"  toml:"broker"`
	                                                 ^
config.go:120:51: tag is not aligned, should be: mapstructure:"storage"    toml:"storage" (tagalign)
	Storage        StorageConfiguration              `mapstructure:"storage" toml:"storage"`
	                                                 ^
config.go:121:51: tag is not aligned, should be: mapstructure:"logging"    toml:"logging" (tagalign)
	Logging        logger.LoggingConfiguration       `mapstructure:"logging" toml:"logging"`
	                                                 ^
config.go:123:51: tag is not aligned, should be: mapstructure:"metrics"    toml:"metrics" (tagalign)
	Metrics        MetricsConfiguration              `mapstructure:"metrics" toml:"metrics"`
	                                                 ^
config.go:124:51: tag is not aligned, should be: mapstructure:"tracker"    toml:"tracker" (tagalign)
	Tracker        TrackerConfiguration              `mapstructure:"tracker" toml:"tracker"`
	                                                 ^
config.go:125:51: tag is not aligned, should be: mapstructure:"sentry"     toml:"sentry" (tagalign)
	Sentry         logger.SentryLoggingConfiguration `mapstructure:"sentry" toml:"sentry"`
	                                                 ^
config.go:131:19: tag is not aligned, should be: mapstructure:"address"   toml:"address" (tagalign)
	Address   string `mapstructure:"address" toml:"address"`
	                 ^
config.go:136:21: tag is not aligned, should be: mapstructure:"topic"        toml:"topic" (tagalign)
	Topic       string `mapstructure:"topic" toml:"topic"`
	                   ^
consumer.go:93:37: json(camel): got 'OrgID' want 'orgId' (tagliatelle)
	Organization  *types.OrgID         `json:"OrgID"`
	                                   ^
consumer.go:94:37: json(camel): got 'AccountNumber' want 'accountNumber' (tagliatelle)
	AccountNumber *types.AccountNumber `json:"AccountNumber"`
	                                   ^
consumer.go:95:37: json(camel): got 'ClusterName' want 'clusterName' (tagliatelle)
	ClusterName   *types.ClusterName   `json:"ClusterName"`
	                                   ^
consumer.go:96:37: json(camel): got 'Report' want 'report' (tagliatelle)
	Report        *Report              `json:"Report"`
	                                   ^
consumer.go:98:34: json(camel): got 'LastChecked' want 'lastChecked' (tagliatelle)
	LastChecked string              `json:"LastChecked"`
	                                ^
consumer.go:99:34: json(camel): got 'Version' want 'version' (tagliatelle)
	Version     types.SchemaVersion `json:"Version"`
	                                ^
consumer.go:100:34: json(camel): got 'RequestId' want 'requestId' (tagliatelle)
	RequestID   types.RequestID     `json:"RequestId"`
	                                ^
kafka_producer.go:65:19: json(camel): got 'request_id' want 'requestId' (tagliatelle)
	RequestID string `json:"request_id"`
	                 ^
ccx_notification_writer_test.go:114:3: expected-actual: need to reverse actual and expected values (testifylint)
		assert.Equal(t, code, main.ExitStatusOK)
		^
ccx_notification_writer_test.go:115:3: error-nil: use assert.NoError (testifylint)
		assert.Nil(t, err)
		^
ccx_notification_writer_test.go:139:3: expected-actual: need to reverse actual and expected values (testifylint)
		assert.Equal(t, code, main.ExitStatusOK)
		^
ccx_notification_writer_test.go:140:3: error-nil: use assert.NoError (testifylint)
		assert.Nil(t, err)
		^
ccx_notification_writer_test.go:174:3: expected-actual: need to reverse actual and expected values (testifylint)
		assert.Equal(t, code, main.ExitStatusOK)
		^
config_test.go:85:2: error-nil: use assert.NoError (testifylint)
	assert.Nil(t, err)
	^
config_test.go:155:2: empty: use assert.Empty (testifylint)
	assert.Equal(t, "", storageCfg.PGParams)
	^
config_test.go:156:2: bool-compare: use assert.True (testifylint)
	assert.Equal(t, true, storageCfg.LogSQLQueries)
	^
config_test.go:171:2: bool-compare: use assert.True (testifylint)
	assert.Equal(t, true, loggingCfg.Debug)
	^
config_test.go:172:2: empty: use assert.Empty (testifylint)
	assert.Equal(t, "", loggingCfg.LogLevel)
	^
config_test.go:187:2: bool-compare: use assert.False (testifylint)
	assert.Equal(t, false, cfg.Debug)
	^
config_test.go:233:2: require-error: for error assertions use require (testifylint)
	assert.NoError(t, err, "Failed loading configuration file")
	^
config_test.go:314:2: empty: use assert.Empty (testifylint)
	assert.Equal(t, "", brokerCfg.Addresses)
	^
kafka_producer_test.go:58:2: require-error: for error assertions use require (testifylint)
	assert.EqualError(t, err, expectedErrorMessage1)
	^
migration_test.go:59:2: error-is-as: invalid usage of assert.Error, use assert.ErrorIs instead (testifylint)
	assert.Error(t, main.Migrate(connection, 1), mockedError)
	^
migration_test.go:95:2: error-is-as: invalid usage of assert.Error, use assert.ErrorIs instead (testifylint)
	assert.Error(t, main.Migrate(connection, 1), mockedError)
	^
migration_test.go:179:2: error-is-as: invalid usage of assert.Error, use assert.ErrorIs instead (testifylint)
	assert.Error(t, main.Migrate(connection, 1), mockedError)
	^
migration_test.go:1194:2: require-error: for error assertions use require (testifylint)
	assert.NoError(t, main.Migrate(connection, 7))
	^
config_benchmark_test.go:32:6: test helper function should start from b.Helper() (thelper)
func mustLoadBenchmarkConfiguration(b *testing.B) main.ConfigStruct {
     ^
config_test.go:55:6: test helper function should start from t.Helper() (thelper)
func mustSetEnv(t *testing.T, key, val string) {
     ^
consumer_test.go:949:6: test helper function should start from t.Helper() (thelper)
func testShrinkedMessage(t *testing.T, inputMessage main.Report) {
     ^
db_benchmark_test.go:304:6: test helper function should start from b.Helper() (thelper)
func setup(b *testing.B) *sql.DB {
     ^
db_benchmark_test.go:330:6: test helper function should start from b.Helper() (thelper)
func execSQLStatement(b *testing.B, connection *sql.DB, statement string) {
     ^
logging_test.go:58:6: test helper function should start from t.Helper() (thelper)
func checkCapture(t *testing.T, err error) {
     ^
ccx_notification_writer.go:501:38: startHTTPServer - result 0 (error) is always nil (unparam)
func startHTTPServer(address string) error {
                                     ^
consumer.go:275:40: (*KafkaConsumer).Close - result 0 (error) is always nil (unparam)
func (consumer *KafkaConsumer) Close() error {
                                       ^
config_test.go:56:9: os.Setenv() could be replaced by t.Setenv() in mustSetEnv (usetesting)
	err := os.Setenv(key, val)
	       ^
config_benchmark_test.go:49:3: variable name 'm' is too short for the scope of its usage (varnamelen)
		m := main.GetMetricsConfiguration(&configuration)
		^
config_benchmark_test.go:90:3: variable name 'm' is too short for the scope of its usage (varnamelen)
		m := main.GetLoggingConfiguration(&configuration)
		^
consumer.go:537:27: parameter name 'r' is too short for the scope of its usage (varnamelen)
func checkReportStructure(r Report) error {
                          ^
consumer_test.go:649:23: parameter name 's' is too short for the scope of its usage (varnamelen)
func NewDummyConsumer(s main.Storage) *main.KafkaConsumer {
                      ^
kafka_producer_test.go:167:2: variable name 'p' is too short for the scope of its usage (varnamelen)
	p := main.Producer{
	^
mig_0002_add_event_target_col.go:38:15: parameter name 'tx' is too short for the scope of its usage (varnamelen)
	StepUp: func(tx *sql.Tx, _ types.DBDriver) error {
	             ^
mig_0005_create_read_errors_table.go:38:15: parameter name 'tx' is too short for the scope of its usage (varnamelen)
	StepUp: func(tx *sql.Tx, _ types.DBDriver) error {
	             ^
mig_0006_on_delete_cascade_from_errors_table.go:38:15: parameter name 'tx' is too short for the scope of its usage (varnamelen)
	StepUp: func(tx *sql.Tx, _ types.DBDriver) error {
	             ^
storage.go:460:2: variable name 'tx' is too short for the scope of its usage (varnamelen)
	tx, err := storage.connection.Begin()
	^
storage.go:611:2: variable name 'tx' is too short for the scope of its usage (varnamelen)
	tx, err := storage.connection.Begin()
	^
storage.go:658:2: variable name 'tx' is too short for the scope of its usage (varnamelen)
	tx, err := storage.connection.Begin()
	^
consumer.go:359:2: unnecessary trailing newline (whitespace)
	}
	^
config.go:209:26: error returned from external package is unwrapped: sig: func (*github.com/BurntSushi/toml.Encoder).Encode(v any) error (wrapcheck)
			return configuration, err
			                      ^
config.go:218:26: error returned from external package is unwrapped: sig: func github.com/spf13/viper.ReadConfig(in io.Reader) error (wrapcheck)
			return configuration, err
			                      ^
config.go:235:25: error returned from external package is unwrapped: sig: func github.com/spf13/viper.Unmarshal(rawVal any, opts ...github.com/spf13/viper.DecoderConfigOption) error (wrapcheck)
		return configuration, err
		                      ^
consumer.go:161:15: error returned from external package is unwrapped: sig: func github.com/Shopify/sarama.NewConsumerGroup(addrs []string, groupID string, config *github.com/Shopify/sarama.Config) (github.com/Shopify/sarama.ConsumerGroup, error) (wrapcheck)
		return nil, err
		            ^
consumer.go:568:24: error returned from external package is unwrapped: sig: func encoding/json.Unmarshal(data []byte, v any) error (wrapcheck)
		return deserialized, err
		                     ^
db_benchmark_test.go:261:31: error returned from external package is unwrapped: sig: func os.Setenv(key string, value string) error (wrapcheck)
		return main.ConfigStruct{}, err
		                            ^
db_benchmark_test.go:266:31: error returned from external package is unwrapped: sig: func github.com/RedHatInsights/ccx-notification-writer.LoadConfiguration(configFileEnvVariableName string, defaultConfigFile string) (github.com/RedHatInsights/ccx-notification-writer.ConfigStruct, error) (wrapcheck)
		return main.ConfigStruct{}, err
		                            ^
db_benchmark_test.go:280:15: error returned from external package is unwrapped: sig: func github.com/RedHatInsights/ccx-notification-writer.NewStorage(configuration *github.com/RedHatInsights/ccx-notification-writer.StorageConfiguration) (*github.com/RedHatInsights/ccx-notification-writer.DBStorage, error) (wrapcheck)
		return nil, err
		            ^
db_benchmark_test.go:289:15: error returned from external package is unwrapped: sig: func github.com/RedHatInsights/ccx-notification-writer.NewStorage(configuration *github.com/RedHatInsights/ccx-notification-writer.StorageConfiguration) (*github.com/RedHatInsights/ccx-notification-writer.DBStorage, error) (wrapcheck)
		return nil, err
		            ^
kafka_producer.go:158:10: error returned from external package is unwrapped: sig: func encoding/json.Marshal(v any) ([]byte, error) (wrapcheck)
		return err
		       ^
scram_client.go:16:10: error returned from external package is unwrapped: sig: func (github.com/xdg/scram.HashGeneratorFcn).NewClient(username string, password string, authzID string) (*github.com/xdg/scram.Client, error) (wrapcheck)
		return err
		       ^
storage.go:462:10: error returned from external package is unwrapped: sig: func (*database/sql.DB).Begin() (*database/sql.Tx, error) (wrapcheck)
		return err
		       ^
storage.go:522:10: error returned from external package is unwrapped: sig: func (*database/sql.DB).Begin() (*database/sql.Tx, error) (wrapcheck)
		return err
		       ^
storage.go:537:12: error returned from external package is unwrapped: sig: func (*database/sql.Tx).Exec(query string, args ...any) (database/sql.Result, error) (wrapcheck)
				return err
				       ^
storage.go:590:14: error returned from external package is unwrapped: sig: func (*database/sql.Row).Scan(dest ...any) error (wrapcheck)
		return -1, err
		           ^
storage.go:602:14: error returned from external package is unwrapped: sig: func (*database/sql.Row).Scan(dest ...any) error (wrapcheck)
		return -1, err
		           ^
storage.go:613:10: error returned from external package is unwrapped: sig: func (*database/sql.DB).Begin() (*database/sql.Tx, error) (wrapcheck)
		return err
		       ^
storage.go:629:11: error returned from external package is unwrapped: sig: func (*database/sql.Tx).Exec(query string, args ...any) (database/sql.Result, error) (wrapcheck)
			return err
			       ^
storage.go:636:11: error returned from external package is unwrapped: sig: func (*database/sql.Tx).Exec(query string, args ...any) (database/sql.Result, error) (wrapcheck)
			return err
			       ^
storage.go:708:10: error returned from external package is unwrapped: sig: func (*database/sql.DB).Query(query string, args ...any) (*database/sql.Rows, error) (wrapcheck)
		return err
		       ^
storage.go:779:13: error returned from external package is unwrapped: sig: func (*database/sql.DB).Exec(query string, args ...any) (database/sql.Result, error) (wrapcheck)
		return 0, err
		          ^
storage.go:785:13: error returned from interface method should be wrapped: sig: func (database/sql.Result).RowsAffected() (int64, error) (wrapcheck)
		return 0, err
		          ^
ccx_notification_writer.go:189:2: ranges should only be cuddled with assignments used in the iteration (wsl)
	for _, addr := range strings.Split(brokerConfiguration.Addresses, ",") {
	^
ccx_notification_writer.go:206:3: if statements should only be cuddled with assignments (wsl)
		if !connected {
		^
ccx_notification_writer.go:312:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
ccx_notification_writer.go:344:2: expressions should not be cuddled with blocks (wsl)
	log.Info().Int(rowsDeletedMessage, affected).Msg("Cleanup `new_reports` finished")
	^
ccx_notification_writer.go:402:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
ccx_notification_writer.go:432:2: expressions should not be cuddled with blocks (wsl)
	log.Info().Int(rowsDeletedMessage, affected).Msg("Cleanup `read_errors` finished")
	^
ccx_notification_writer.go:495:2: assignments should only be cuddled with other assignments (wsl)
	consumer.Tracker = pt
	^
ccx_notification_writer.go:565:1: block should not end with a whitespace (or comment) (wsl)
}
^
ccx_notification_writer.go:632:2: expressions should not be cuddled with blocks (wsl)
	log.Debug().Msg("Started")
	^
ccx_notification_writer.go:678:2: only one cuddle assignment allowed before if statement (wsl)
	if err != nil {
	^
ccx_notification_writer.go:690:3: if statements should only be cuddled with assignments used in the if statement itself (wsl)
		if err != nil {
		^
ccx_notification_writer.go:696:3: if statements should only be cuddled with assignments (wsl)
		if vers < 0 || vers > math.MaxUint32 {
		^
ccx_notification_writer.go:698:4: assignments should only be cuddled with other assignments (wsl)
			exitStatus = ExitStatusMigrationError
			^
ccx_notification_writer.go:709:3: assignments should only be cuddled with other assignments (wsl)
		exitStatus = ExitStatusMigrationError
		^
ccx_notification_writer_test.go:87:3: only cuddled expressions if assigning variable or using from line above (wsl)
		main.ShowConfiguration(&configuration)
		^
config.go:283:3: ranges should only be cuddled with assignments used in the iteration (wsl)
		for _, broker := range clowder.LoadedConfig.Kafka.Brokers {
		^
config.go:297:4: if statements should only be cuddled with assignments (wsl)
			if clowderBrokerCfg.Sasl != nil {
			^
config_test.go:215:2: expressions should not be cuddled with declarations or returns (wsl)
	os.Clearenv()
	^
config_test.go:244:2: expressions should not be cuddled with declarations or returns (wsl)
	os.Clearenv()
	^
config_test.go:471:2: declarations should never be cuddled (wsl)
	var password = "password"
	^
config_test.go:472:2: declarations should never be cuddled (wsl)
	var saslMechanism = "mechanism"
	^
config_test.go:473:2: declarations should never be cuddled (wsl)
	var securityProtocol = "security_protocol"
	^
consumer.go:373:3: expressions should not be cuddled with declarations or returns (wsl)
		logMessageWarning(consumer, msg, *message, warning)
		^
consumer.go:397:1: block should not end with a whitespace (or comment) (wsl)
}
^
db_benchmark_test.go:493:4: for statements should only be cuddled with assignments used in the iteration (wsl)
			for i := 0; i < reportsCount; i++ {
			^
logging_test.go:103:3: only cuddled expressions if assigning variable or using from line above (wsl)
		main.LogDuration(startTime, endTime, 9999, "test message")
		^
logging_test.go:124:3: only cuddled expressions if assigning variable or using from line above (wsl)
		main.LogMessageInfo(consumer, &originalMessage, parsedMessage, testEventMessage)
		^
migration_test.go:1183:2: only one cuddle assignment allowed before range statement (wsl)
	for _, expectedStatement := range expectedStatements {
	^
migration_test.go:1274:2: only one cuddle assignment allowed before range statement (wsl)
	for _, expectedStatement := range expectedStatements {
	^
ccx_notification_writer.go:185:10: must be dispatched by Msg or Send method (zerologlint)
	log.Info().
	        ^
412 issues:
* cyclop: 2
* depguard: 42
* dupl: 11
* err113: 24
* errorlint: 1
* exhaustruct: 50
* forbidigo: 7
* funlen: 2
* gochecknoglobals: 21
* gochecknoinits: 3
* goconst: 9
* godot: 3
* godox: 4
* gosec: 1
* interfacebloat: 1
* ireturn: 1
* lll: 25
* makezero: 3
* misspell: 5
* mnd: 2
* nakedret: 3
* nestif: 1
* nlreturn: 6
* nolintlint: 1
* nonamedreturns: 4
* paralleltest: 50
* predeclared: 1
* promlinter: 9
* revive: 1
* rowserrcheck: 2
* sqlclosecheck: 2
* staticcheck: 8
* tagalign: 8
* tagliatelle: 8
* testifylint: 18
* thelper: 6
* unparam: 2
* usetesting: 1
* varnamelen: 11
* whitespace: 1
* wrapcheck: 22
* wsl: 29
* zerologlint: 1
